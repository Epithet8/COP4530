<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Language" content="en-us" /><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>Project 2</title><style type="text/css">.style1 {	text-align: center;}.style2 {	text-align: left;}.style3 {	margin-left: 80px;}.style4 {	text-align: left;	margin-left: 40px;}</style></head><body><h4 class="style1">Project 2: Vector Class Template Container</h4><p class="style1">Due 10/06/2023</p><p class="style2"><strong>Educational Objectives</strong>: Understanding generic programming and information hiding by developing generic containers; getting familiar with the concept of class template and its usage; using iterators, namespace, and operator overloading; analyzing algorithm complexity.&nbsp; </p><p class="style2"><strong>Statement of Work</strong>: Implement a vector class template Vector and its associated iterator. Analyze the complexity of member functions of the developed Vector. </p><p class="style2"><strong>Requirements</strong>:</p><ol>	<li>	<p class="style2">A header file Vector.h is provided, which contains the 	interface of the vector class template Vector. In addition to data members 	and member functions of Vector, both iterator and const_iterator are also 	defined for Vector. The header file also contains a number of global 	non-class function templates (overloaded operators). You <strong>cannot</strong> change anything in the 	Vector.h file.</p>	</li>	<li>	<p class="style2">A driver program test_vector.cpp is also provided. It is 	used to test your implementation of the vector class template 	for different data types (it tests Vector&lt;int&gt; and Vector&lt;string&gt;). Similarly, 	you cannot change anything in the test_vector.cpp file. Note that additional 	tests will be performed to check your implementation of the Vector class 	template. </p>	</li>	<li>	<p class="style2">You need to implement the member functions of the vector 	class template Vector in a file named Vector.hpp. Note that, Vector.hpp has been 	included in the header file Vector.h (towards the end of the file). As we have 	discussed in class, you should not try to compile Vector.hpp (or Vector.h). 	Instead, you should compile the driver program test_driver.cpp to obtain the 	executable program. You need to implement all the member functions of Vector class template and non-class global overloaded functions 	operator==(), operator!=(), and operator&lt;&lt;() included in Vector.h.&nbsp; 	Vector has three member variables, theSize, theCapacity, and array. Member variable theSize 	records the number of elements 	currently stored in the vector; theCapacity indicates the maximum number of 	elements the vector can hold without requesting new memory allocation; and 	array is a pointer of type T (the memory should be dynamically allocated).&nbsp; 	The member variable array is used to store elements of the vector. The 	design of the Vector container closely follows the vector container included 	in C++/STL, which is also similar to the one presented in the textbook. It 	is OK for you to adapt the code provided in the textbook. However, you need 	to note that there are minor differences between 	the design of the Vector class in this project and the one given given in 	the textbook. In particular, whenever you need to insert a new element into 	the vector and the vector is full, you need to double the capacity. If the 	current capacity is zero, change the new capacity to 1. We describe the requirements of 	each function in the following.</p>	</li></ol><p class="style2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Member functions of Vector class template:&nbsp;</p><ul class="style3">	<li>	<p class="style2">Vector(): Default zero-parameter	constructor. This will create an empty vector with both size and capacity to 	be zero. You need to initialize the member variables. In particular, you 	need to assign array to NULL (nullptr for c++11).</p>	</li>	<li>	<p class="style2">Vector(const Vector &rhs): Copy constructor. Create the 	new vector using elements in existing vector rhs.</p>	</li>	<li>	<p class="style2">Vector(Vector &amp;&amp;rhs): Move constructor.</p>	</li>	<li>	<p class="style2">Vector(int num, const T &amp; val = T()): Construct 		a Vector with num elements, all initialized with value val. Note that	the capacity should also be num.</p>	</li>	<li>	<p class="style2">Vector(const_iterator start, const_iterator 		end): Construct a Vector with elements from another Vector between start and 		end. Including the element referred to by the start iterator, but not 	by the end iterator, that is, the new vector should contain the elements in the 	range [start, end).</p>	</li>	<li>	<p class="style2">~Vector(): Destructor. You should properly reclaim memory.</p>	</li>	<li>	<p class="style2">operator[](index): Index operator. Return reference to the 	element at the specified location. No error checking on value of index. Note 	that there are two versions of the index operator.</p>	</li>	<li>	<p class="style2">operator=(const Vector &amp;rhs): Copy assignment operator</p>	</li>	<li>	<p class="style2">operator=(Vector &amp;&amp;rhs): Move assignment operator</p>	</li>	<li>	<p class="style2">at(index): Return reference to the element at the 	specified location. Throw &quot;out_of_range&quot; exception if index is not in the 	valid range [0, theSize).&nbsp; There are two versions of this member 	function.</p>	</li>	<li>	<p class="style2">front() and back(): Return reference to the	first and last element in the vector, respectively. There are two versions 	of both member functions. </p>	</li>	<li>	<p class="style2">size(): Return the number of elements currently stored in the	vector. </p>	</li>	<li>	<p class="style2">capacity(): Return the number of elements that can be 	stored in the vector without any new memory allocation.</p>	</li>	<li>	<p class="style2">empty(): Return true if no element is in the	vector; otherwise, return false.</p>	</li>	<li>	<p class="style2">clear(): Delete all elements in the vector. Memory 	associated with the vector does not need to be reclaimed.</p>	</li>	<li>	<p class="style2">push_back(): Insert a new	object as the last element into the vector. </p>	</li>	<li>	<p class="style2">pop_back(): Delete the last element in the vector. </p> 	</li>	<li>	<p class="style2">resize(newSize, newValue): Change the size of the vector 	to newSize. If newSize is greater than the current size theSize, the new 	positions in the vector should hold the value newValue. Note that capacity 	may also be changed accordingly. </p>	</li>	<li>	<p class="style2">reserve(newCapacity): Change the capacity of the vector to newCapacity, if newCapacity is greater than the current 	capacity of the vector. Otherwise, this function does not change the 	capacity of the vector.</p>	</li>	<li>	<p class="style2">print(ostream &amp;os, char ofc = &#39; &#39;): Print all 		elements in the Vector, using character ofc as the deliminator between 	elements of the vector.</p>	</li>	<li>	<p class="style2">begin(): Return iterator to the first element in the 	vector. No error checking is required. There are two versions of this member 	function.</p>	</li>	<li>	<p class="style2">end(): Return iterator to the end marker of	the vector (the position after the last element in the vector). No error 	checking is required. There are two versions of this member function.</p>	</li>	<li>	<p class="style2">insert(iterator itr, const T &amp; val): Insert 		value val ahead of the element referred by the iterator itr. All current 	elements in the vector starting at itr 	should be pushed back by one position. The return value is the iterator 	referring to the newly inserted element.</p>	</li>	<li>	<p class="style2">erase(iterator itr): Delete element referred to 		by itr. The return value is the iterator referring to the element following the deleted 	element.</p>	</li>	<li>	<p class="style2">erase(iterator start, iterator end): Delete all elements 	between start and end (including start but not end), that is, all elements 	in the range [start, end). The return value is the iterator referring 	to the element following the last element being deleted.</p>	</li>	<li>	<p class="style2">doubleCapacity(): Double the capacity of the vector. If 	the current capacity is 0, set the new capacity to 1. This is a private 	member function, which can be used by other member functions such as 	push_back(). Note that this function can call reserve() member function to do the real 	work, after calculating the proper capacity value. </p>	</li></ul><p class="style2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Non-class global functions&nbsp;</p><ul class="style3">	<li>	<p class="style2">operator==(const Vector&lt;T&gt; &amp; lhs, 		const Vector&lt;T&gt; &amp; rhs): Check if two vectors contain the same sequence of 		elements. Two vectors are equal if they have the same number of elements 		and the elements at the corresponding position are equal.</p>	</li>	<li>	<p class="style2">operator!=(const Vector&lt;T&gt; &amp; lhs, 		const Vector&lt;T&gt; &amp; rhs): Opposite of operator==().</p>	</li>	<li>	<p class="style2">operator&lt;&lt;(ostream &amp; os, const 		Vector&lt;T&gt; &amp; v): Print out all elements in Vector v by calling 		Vector&lt;T&gt;::print() function.&nbsp; </p>	</li></ul><ol>	<li value="4">	<p class="style2">Write a makefile for your project and name your executable 	as proj2.x. Your program must be able to compile and run on the linprog 	machines.</p>	</li>	<li>	<p class="style2">Analyze the worst-case run-time complexity of the member 	  functions empty(), erase(iterator itr), and pop_back() of the Vector.	  Give the complexity in the form 	of Big-O. Your analysis must be clearly 	understandable by others. Name the file containing the complexity analysis 	as &quot;analysis.txt&quot;. </p>	</li></ol><p class="style2"><strong>Downloads</strong></p><p class="style4">Click <a href="proj2_provided.tar">here</a> to download the tar file, which contains the following files: Vector.h, test_vector.cpp, and proj2.x. The sample executable program proj2.x was compiled on a linprog machine from test_vector.cpp. </p><p class="style4">Note: The first person to find a programming error in our program will get a bonus point! (There is no known error in the program.)</p><p class="style2"><strong>Deliverables</strong></p><p class="style4">Turn in files makefile, Vector.hpp, and analysis.txt in a single tar file via the Canvas. If you cannot finish all functions, you must also submit a modified test_vector.cpp (this filemust be the original provided test_vector.cpp with some lines commented out) that would allow the executable to be produced to avoid your program being treated as having compiling errors.</p><p class="style2"><strong>Grading</strong></p><!--95 points for programming and 5 points for complexity analysis based on the grading rubric. --><ul><li>Typing 'make' in the subdirectory containing your submitted files with the provided Vector.h and test_vector.cpp (or your modified test_vector.cpp) should produce the executable proj2.x on linprog. If the program or makefile has any kind of (compiling) errors, no more than 10 points will be awarded. </li><li>proj2.x is successfully produced (15 points).</li><li>Pass all test cases in the provided test_vector.cpp (40 points)</li><li>Pass all test cases in another testing program (not provided) (12 points)</li><li>Implementation of the functions (1 point for each public function, 27 points total)</li><li>Complexity analysis for member function erase(iterator itr). 3 points for the big O form. 3 points    for explanation (6 points)</li></ul><p class="style2"><strong>Hints</strong></p><ul><li>Run proj1.x, compare with test_vector.cpp, and find out the corresponding line and output. </li><li>Work through test_vector.cpp, comment out lines if necessary. After implementing each function, you should test the function before implementing the next function. Make progress towards completing the project steadily, but surely.</li><li>Write your own additional test programs to make sure that all public member functions of Vector are tested.</li></ul></body></html>